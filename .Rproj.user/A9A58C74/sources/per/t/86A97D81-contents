---
title: 'Alport_mice'
author: Geremy Clair
date: August 13, 2020
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
    theme : cerulean
    code_folding: hide
---

```{r knit_options, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=6, echo = TRUE, results = TRUE, warning = FALSE, message=FALSE) 
options(repos=structure(c(CRAN="https://mirror.ibcp.fr/pub/CRAN/")))
setwd("~/Documents/06 - Fun-GCAT/02 - Tissue proteomics/02 - Perin alport mice higher loading/")
```

# Required libraries

The required libraries are loaded 
- RomicsProcessor written by Geremy Clair (2020) is used to perform trackable transformation and statistics to the dataset 
- proteinminion written by Geremy Clair (2020) is used to extract fasta information and to perform gene ontology and KEGG pathways enrichement analysis (2020)
```{r load_packages}
library("RomicsProcessor")
library("proteinminion")
library("DT") #for the rendering of the enrichment tables 
```

# Fasta and protein ontologies download using 'Protein Mini-On'

Using the package 'Protein Mini-on' (Geremy Clair 2020, in prep.), The fasta file was downloaded from Uniprot.
It was then uploaded by Matthew Monroe on the PNNL's Data Management System (PMID: 16470653) the 05/01/2020.
```{r download_fasta}
if(!file.exists("Mus_musculus_proteome_up000000589_2020_07_13.fasta")){
  download_UniProtFasta(proteomeID = "up000000589", reviewed = F, export=T, file="Mus_musculus_proteome_up000000589_2020_07_13.fasta")
  }
```

Then we've extracted and parsed the details contained in the fasta file header into a table containing a list of details for each protein.
```{r UniProtFasta_info}
UniProtFasta_info<-UniprotFastaParser(file = "Mus_musculus_proteome_up000000589_2020_07_13.fasta")
```

For each entry, 'Protein Mini-On' was use to download Gene Ontology (GO) terms and KEGG ids associated with the proteins. This upload was performed the exact same day as the download of the fasta file was done to ensure that the IDs will be identical as the ones present in the fasta file used).
```{r UniProtTable_download}
if(file.exists("UniprotTable_Mus_musculus_proteome_up000000589_2020_07_13.csv")){
  UniProtTable<-read.csv("UniprotTable_Mus_musculus_proteome_up000000589_2020_07_13.csv")
  }else{
  download_UniProtTable(proteomeID = "up000000589", reviewed = F)
  write.csv(UniProtTable,("UniprotTable_Mus_musculus_proteome_up000000589_2020_07_13.csv"),row.names=FALSE)
  }
```

'Protein-Mini-on' was then used to generate a table (UniProtTable) containing the list of GOs and their associated protein IDs
```{r UniProtTable_GO_generation}
if(file.exists("UniProtTable_GO.csv")){
  UniProtTable_GO<-read.csv(file="UniProtTable_GO.csv")
}else{
generate_UniProtTable_GO()
write.csv(UniProtTable_GO,file="UniProtTable_GO.csv",row.names=FALSE)
}
```

'Protein-Mini-on' was used to download similar information from KEGG for the Pathways associated with each protein
```{r UniProtTable_KEGG_generation}
if(file.exists("UniProtTable_KEGG.csv")){
  UniProtTable_KEGG<-read.csv(file="UniProtTable_KEGG.csv")
}else{
generate_UniProtTable_KEGG()
write.csv(UniProtTable_KEGG,file="UniProtTable_KEGG.csv",row.names=FALSE)
}
```

# MaxQuant import

```{r}
data<-extractMaxQuant("proteinGroups.txt",quantification_type = "iBAQ",cont.rm = T,site.rm = T,rev.rm = T)
IDsdetails<-extractMaxQuantIDs("proteinGroups.txt",cont.rm = T,site.rm = T,rev.rm = T)
IDsdetails<-cbind(UniProt_Name=sub(".*\\|","",IDsdetails$protein.ids), IDsdetails)
colnames(data)<- sub("iBAQ.","",colnames(data))
data[,1]<- sub(".*\\|","",data[,1])
metadata<- read.csv(file = "metadata.csv")
colnames(metadata)<-tolower(colnames(metadata))
```

# Romics_object creation

The data and metadata were placed in an romics_object, the sample names were retrieved from the metadata, the condition  will be use for the coloring of the Figures.
```{r create_romics}
romics_proteins<- romicsCreateObject(data, metadata,main_factor = "Condition")
```


# Full data analysis

## Data cleaning and normalization

The missingness was evaluated for each channel/sample
```{r missingness_eval_full}
romics_proteins<- romicsZeroToMissing(romics_proteins)
romicsPlotMissing(romics_proteins)
```

The dataset looked to be missing a lot of values in the group G1 apc compared to the other conditions. we created a subseted object that will not comprise this condition for later use
```{r}
romics_proteins_noapc<-romicsSubset(romics_proteins,subset_vector = "A_G1_APC",type = "drop",by = "level",factor = "Condition")
```


The proteins to be conserved for quantification were selected to contain at least 60% of complete value for a given condition, the overall missingness was evaluated after filtering.
```{r missing_filter_full}
romics_proteins<-romicsFilterMissing(romics_proteins,percentage_completeness = 60)
print(paste0(nrow(romics_proteins$data),"/", nrow(romics_proteins$original_data)," proteins remained after filtering", " (",round(nrow(romics_proteins$data)/nrow(romics_proteins$original_data)*100,2),"%)."))
romicsPlotMissing(romics_proteins)
```

The data was log2 transformed, the distriution boxplot were then plotted
```{r log2_full}
romics_proteins<-log2transform(romics_proteins)
distribBoxplot(romics_proteins)
```

As the same quantity of protein was labelled for each sample, the expectation is that the distribution of the protein abundance is centered, therefore a median centering was performed prior to plot again the distribution boxplots.
```{r median_norm_full}
romics_proteins<-medianCenterSample(romics_proteins)
distribBoxplot(romics_proteins)
```

## Grouping evaluation


A PCA was performed prior imputation of the missing data
```{r PCA_no_imput_full}
indPCAplot(romics_proteins, ncp=5,plotType = "percentage")
indPCAplot(romics_proteins, ncp=5,plotType = "individual",Xcomp=1,Ycomp =2)
indPCAplot(romics_proteins, ncp=5, plotType = "individual",Xcomp=2,Ycomp =3)
```

## Data imputation

For some of the subsequent statistics imputations are required, we performed an imputation by assuming that the "non-detected" proteins were either low abundance or missing using the method developped by Tyranova et al. (PMID: 27348712). The gray distribution is the data distribution, the yellow distribution is the one for the random values used for imputation.
```{r imput_missing_full}
imputeMissingEval(romics_proteins,nb_stdev = 2,width_stdev = 0.5, bin=1)
romics_proteins<-imputeMissing(romics_proteins,nb_stdev = 2,width_stdev = 0.5)
```

The hclust and PCA grouping were checked again after imputation
```{r grouping_after_imputation_full}
romicsHclust(romics_proteins)
indPCAplot(romics_proteins, plotType = "percentage")
indPCAplot(romics_proteins, plotType = "individual",Xcomp=1,Ycomp =2)
indPCAplot(romics_proteins,  plotType = "individual",Xcomp=2,Ycomp =3)
```

## Statistics

The means and stdev are calculated for each group
```{r Means_stdevs_full}
romics_proteins<-romicsMean(romics_proteins)
romics_proteins<-romicsSd(romics_proteins)
```

Some general statistics are performed (ANOVA, paired T.tests).
```{r statistics_full}
romics_proteins<-romicsANOVA(romics_proteins)
print(paste0(sum(romics_proteins$statistics$ANOVA_p<0.05), " proteins had an ANOVA p<0.05."))
print(paste0(sum(romics_proteins$statistics$ANOVA_padj<0.05), " proteins had an ANOVA padjusted<0.05."))
```

A heatmap depicting the proteins passing an ANOVA p<0.05 is plotted, the clusters obtained were saved in the statistics.
```{r Heatmap_full}
romicsHeatmap(romics_proteins,variable_hclust_number = 5,ANOVA_filter = "p", p=0.05,sample_hclust = F)
romics_proteins<-romicsVariableHclust(romics_proteins,clusters = 5,ANOVA_filter = "p",p= 0.05,plot = F)
romics_proteins<-romicsZscores(romics_proteins)
```

T tests were then performed to compare specific conditions together.
```{r T_test_all}
romics_proteins<-romicsTtest(romics_proteins)
romicsVolcano(romics_proteins)
```

## Enrichment analysis

Here the most interesting thing is the green cluster in the heatmap which seem to be highly expressed in G1APC compared to the other conditions.We therefore performed an enrichment analysis on these different clusters (note that the order of the clusters is NOT logical the color of the cluster is the following)

Purple = Cluster2
Blue = Cluster1
Green = Cluster5
GoldBrown = Cluster3
PinkRed = Cluster4

```{r enrichment_Clusters}
Clust1<-as.character(t(read.csv(file="Cluster1.csv")))
Clust2<-as.character(t(read.csv(file="Cluster2.csv")))
Clust3<-as.character(t(read.csv(file="Cluster3.csv")))
Clust4<-as.character(t(read.csv(file="Cluster4.csv")))
Clust5<-as.character(t(read.csv(file="Cluster5.csv")))
Universe<-as.character(t(read.csv(file="Universe.csv")))

Clust1_GO<-cbind(Cluster=1, UniProt_GO_Fisher(Clust1,Universe))
Clust2_GO<-cbind(Cluster=2, UniProt_GO_Fisher(Clust2,Universe))
Clust3_GO<-cbind(Cluster=3, UniProt_GO_Fisher(Clust3,Universe))
Clust4_GO<-cbind(Cluster=4, UniProt_GO_Fisher(Clust4,Universe))
Clust5_GO<-cbind(Cluster=5, UniProt_GO_Fisher(Clust5,Universe))

Clust1_KEGG<-cbind(Cluster=1, UniProt_KEGG_Fisher(Clust1,Universe))
Clust2_KEGG<-cbind(Cluster=2, UniProt_KEGG_Fisher(Clust2,Universe))
Clust3_KEGG<-cbind(Cluster=3, UniProt_KEGG_Fisher(Clust3,Universe))
Clust4_KEGG<-cbind(Cluster=4, UniProt_KEGG_Fisher(Clust4,Universe))
Clust5_KEGG<-cbind(Cluster=5, UniProt_KEGG_Fisher(Clust5,Universe))

Enrichment_clusters<-rbind(Clust1_GO,Clust2_GO,Clust3_GO,Clust4_GO,Clust5_GO,Clust1_KEGG,Clust2_KEGG,Clust3_KEGG,Clust4_KEGG,Clust5_KEGG)
Enrichment_clusters<-Enrichment_clusters[Enrichment_clusters$pval<0.1 & Enrichment_clusters$fold_change>1,]
write.table(Enrichment_clusters,file= "Enrichment_clusters.txt",sep="\t")

datatable(Enrichment_clusters)
```

## Data export
The data generated abd the enrichment analysis are exported as a csv file
```{r data_export_all}
export_stats<-romicsExportData(romics_proteins,statistics = T,missing_data = T)
export_stats<-cbind(UniProt_Name=rownames(export_stats),export_stats)
export_stats<-merge(export_stats,IDsdetails,by="UniProt_Name")
write.csv(export_stats,file= "all_results_with_stats.csv")
```


# NoAPC

The same analysis is performed with the APC condition removed in order to biew easier the differences between the three remaining conditions.

## Data cleaning and normalization
The proteins to be conserved for quantification were selected to contain at least 60% of complete value for a given condition, the overall missingness was evaluated after filtering.
```{r missing_filter_noapc}
romics_proteins_noapc<-romicsFilterMissing(romics_proteins_noapc,percentage_completeness = 60)
print(paste0(nrow(romics_proteins_noapc$data),"/", nrow(romics_proteins_noapc$original_data)," proteins remained after filtering", " (",round(nrow(romics_proteins_noapc$data)/nrow(romics_proteins_noapc$original_data)*100,2),"%)."))
romicsPlotMissing(romics_proteins_noapc)
```

The data was log2 transformed, the distriution boxplot were then plotted
```{r log2_noapc}
romics_proteins_noapc<-log2transform(romics_proteins_noapc)
distribBoxplot(romics_proteins_noapc)
```

As the same quantity of protein was labelled for each sample, the expectation is that the distribution of the protein abundance is centered, therefore a median centering was performed prior to plot again the distribution boxplots.
```{r median_norm_noapc}
romics_proteins_noapc<-medianCenterSample(romics_proteins_noapc)
distribBoxplot(romics_proteins_noapc)
```

## Grouping evaluation


A PCA was performed prior imputation of the missing data
```{r PCA_no_imput_noapc}
indPCAplot(romics_proteins_noapc, ncp=5,plotType = "percentage")
indPCAplot(romics_proteins_noapc, ncp=5,plotType = "individual",Xcomp=1,Ycomp =2)
indPCAplot(romics_proteins_noapc, ncp=5, plotType = "individual",Xcomp=2,Ycomp =3)
```

## Data imputation

For some of the subsequent statistics imputations are required, we performed an imputation by assuming that the "non-detected" proteins were either low abundance or missing using the method developped by Tyranova et al. (PMID: 27348712). The gray distribution is the data distribution, the yellow distribution is the one for the random values used for imputation.
```{r imput_missing_noapc}
imputeMissingEval(romics_proteins_noapc,nb_stdev = 2,width_stdev = 0.5, bin=1)
romics_proteins_noapc<-imputeMissing(romics_proteins_noapc,nb_stdev = 2,width_stdev = 0.5)
```

The hclust and PCA grouping were checked again after imputation
```{r grouping_after_imputation_noapc}
romicsHclust(romics_proteins_noapc)
indPCAplot(romics_proteins_noapc, plotType = "percentage")
indPCAplot(romics_proteins_noapc, plotType = "individual",Xcomp=1,Ycomp =2)
indPCA3D(romics_proteins_noapc)

```

## Statistics

The means and stdev are calculated for each group
```{r Means_stdevs_noapc}
romics_proteins_noapc<-romicsMean(romics_proteins_noapc)
romics_proteins_noapc<-romicsSd(romics_proteins_noapc)
```

Some general statistics are performed (ANOVA, paired T.tests).
```{r statistics_noapc}
romics_proteins_noapc<-romicsANOVA(romics_proteins_noapc)
print(paste0(sum(romics_proteins_noapc$statistics$ANOVA_p<0.05), " proteins had an ANOVA p<0.05."))
print(paste0(sum(romics_proteins_noapc$statistics$ANOVA_padj<0.05), " proteins had an ANOVA padjusted<0.05."))
```

A heatmap depicting the proteins passing an ANOVA p<0.05 is plotted, the clusters obtained were saved in the statistics.
```{r Heatmap_noapc}
romicsHeatmap(romics_proteins_noapc,variable_hclust_number = 3,ANOVA_filter = "p", p=0.05,sample_hclust = F)
romics_proteins_noapc<-romicsVariableHclust(romics_proteins_noapc,clusters = 3,ANOVA_filter = "p",p= 0.05,plot = F)
romics_proteins_noapc<-romicsZscores(romics_proteins_noapc)
```
Here all three clusters seem to present interesting features and enrichment will be performed

T.test were then performed to compare the different conditions together
```{r T_test}
romics_proteins_noapc<-romicsTtest(romics_proteins_noapc)
romicsVolcano(romics_proteins_noapc)
```

## Enrichment groups

For each comparison made here we did 3 types of enrichment:
- proteins up regulated in first group
- proteins down regulated in first group
- protein changing (regardless of the orientation)

```{r enrichment_groups}
A_G1_vs_A_G0_high_in_A_G1<-as.character(t(read.csv("A_G1_vs_A_G0_high_in_A_G1.csv")))
A_G1_vs_A_G0_low_in_A_G1<-as.character(t(read.csv("A_G1_vs_A_G0_low_in_A_G1.csv")))
A_G1_vs_A_G0_changing<-as.character(t(read.csv("A_G1_vs_A_G0_changing.csv")))
WT_G0_vs_A_G0_high_in_WT_G0<-as.character(t(read.csv("WT_G0_vs_A_G0_high_in_WT_G0.csv")))
WT_G0_vs_A_G0_low_in_WT_G0<-as.character(t(read.csv("WT_G0_vs_A_G0_low_in_WT_G0.csv")))
WT_G0_vs_A_G0_changing<-as.character(t(read.csv("WT_G0_vs_A_G0_changing.csv")))
WT_G0_vs_A_G1_high_in_WT_G0<-as.character(t(read.csv("WT_G0_vs_A_G1_high_in_WT_G0.csv")))
WT_G0_vs_A_G1_low_in_WT_G0<-as.character(t(read.csv("WT_G0_vs_A_G1_low_in_WT_G0.csv")))
WT_G0_vs_A_G1_changing<-as.character(t(read.csv("WT_G0_vs_A_G1_changing.csv")))
Universe_groups<-as.character(t(read.csv("Universe_groups.csv")))

A_G1_vs_A_G0_high_in_A_G1_GO<-cbind(Cluster="A_G1_vs_A_G0_high_in_A_G1", UniProt_GO_Fisher(A_G1_vs_A_G0_high_in_A_G1,Universe))
A_G1_vs_A_G0_low_in_A_G1_GO<-cbind(Cluster="A_G1_vs_A_G0_low_in_A_G1", UniProt_GO_Fisher(A_G1_vs_A_G0_low_in_A_G1,Universe))
A_G1_vs_A_G0_changing_GO<-cbind(Cluster="A_G1_vs_A_G0_changing", UniProt_GO_Fisher(A_G1_vs_A_G0_changing,Universe))
WT_G0_vs_A_G0_high_in_WT_G0_GO<-cbind(Cluster="WT_G0_vs_A_G0_high_in_WT_G0", UniProt_GO_Fisher(WT_G0_vs_A_G0_high_in_WT_G0,Universe))
WT_G0_vs_A_G0_low_in_WT_G0_GO<-cbind(Cluster="WT_G0_vs_A_G0_low_in_WT_G0", UniProt_GO_Fisher(WT_G0_vs_A_G0_low_in_WT_G0,Universe))
WT_G0_vs_A_G0_changing_GO<-cbind(Cluster="WT_G0_vs_A_G0_changing", UniProt_GO_Fisher(WT_G0_vs_A_G0_changing,Universe))
WT_G0_vs_A_G1_high_in_WT_G0_GO<-cbind(Cluster="WT_G0_vs_A_G1_high_in_WT_G0", UniProt_GO_Fisher(WT_G0_vs_A_G1_high_in_WT_G0,Universe))
WT_G0_vs_A_G1_low_in_WT_G0_GO<-cbind(Cluster="WT_G0_vs_A_G1_low_in_WT_G0", UniProt_GO_Fisher(WT_G0_vs_A_G1_low_in_WT_G0,Universe))
WT_G0_vs_A_G1_changing_GO<-cbind(Cluster="WT_G0_vs_A_G1_changing", UniProt_GO_Fisher(WT_G0_vs_A_G1_changing,Universe))

A_G1_vs_A_G0_high_in_A_G1_KEGG<-cbind(Cluster="A_G1_vs_A_G0_high_in_A_G1", UniProt_KEGG_Fisher(A_G1_vs_A_G0_high_in_A_G1,Universe))
A_G1_vs_A_G0_low_in_A_G1_KEGG<-cbind(Cluster="A_G1_vs_A_G0_low_in_A_G1", UniProt_KEGG_Fisher(A_G1_vs_A_G0_low_in_A_G1,Universe))
A_G1_vs_A_G0_changing_KEGG<-cbind(Cluster="A_G1_vs_A_G0_changing", UniProt_KEGG_Fisher(A_G1_vs_A_G0_changing,Universe))
WT_G0_vs_A_G0_high_in_WT_G0_KEGG<-cbind(Cluster="WT_G0_vs_A_G0_high_in_WT_G0", UniProt_KEGG_Fisher(WT_G0_vs_A_G0_high_in_WT_G0,Universe))
WT_G0_vs_A_G0_low_in_WT_G0_KEGG<-cbind(Cluster="WT_G0_vs_A_G0_low_in_WT_G0", UniProt_KEGG_Fisher(WT_G0_vs_A_G0_low_in_WT_G0,Universe))
WT_G0_vs_A_G0_changing_KEGG<-cbind(Cluster="WT_G0_vs_A_G0_changing", UniProt_KEGG_Fisher(WT_G0_vs_A_G0_changing,Universe))
WT_G0_vs_A_G1_high_in_WT_G0_KEGG<-cbind(Cluster="WT_G0_vs_A_G1_high_in_WT_G0", UniProt_KEGG_Fisher(WT_G0_vs_A_G1_high_in_WT_G0,Universe))
WT_G0_vs_A_G1_low_in_WT_G0_KEGG<-cbind(Cluster="WT_G0_vs_A_G1_low_in_WT_G0", UniProt_KEGG_Fisher(WT_G0_vs_A_G1_low_in_WT_G0,Universe))
WT_G0_vs_A_G1_changing_KEGG<-cbind(Cluster="WT_G0_vs_A_G1_changing", UniProt_KEGG_Fisher(WT_G0_vs_A_G1_changing,Universe))

Enrichments_Groups<-rbind(A_G1_vs_A_G0_high_in_A_G1_GO,A_G1_vs_A_G0_low_in_A_G1_GO,A_G1_vs_A_G0_changing_GO,
                          WT_G0_vs_A_G0_high_in_WT_G0_GO,WT_G0_vs_A_G0_low_in_WT_G0_GO,WT_G0_vs_A_G0_changing_GO,
                          WT_G0_vs_A_G1_high_in_WT_G0_GO,WT_G0_vs_A_G1_low_in_WT_G0_GO, WT_G0_vs_A_G1_changing_GO,
                          A_G1_vs_A_G0_high_in_A_G1_KEGG,A_G1_vs_A_G0_low_in_A_G1_KEGG,A_G1_vs_A_G0_changing_KEGG,
                          WT_G0_vs_A_G0_high_in_WT_G0_KEGG,WT_G0_vs_A_G0_low_in_WT_G0_KEGG,WT_G0_vs_A_G0_changing_KEGG,
                          WT_G0_vs_A_G1_high_in_WT_G0_KEGG,WT_G0_vs_A_G1_low_in_WT_G0_KEGG, WT_G0_vs_A_G1_changing_KEGG)

Enrichments_Groups<-Enrichments_Groups[Enrichments_Groups$pval<0.05 & Enrichments_Groups$fold_change>1,]

write.table(Enrichments_Groups,file="Enrichment_Groups.txt",sep="\t")

datatable(Enrichments_Groups)
```


## Data export
The data generated abd the enrichment analysis are exported as a csv file
```{r data_export_noapc}
export_stats<-romicsExportData(romics_proteins_noapc,statistics = T,missing_data = T)
export_stats<-cbind(UniProt_Name=rownames(export_stats),export_stats)
export_stats<-merge(export_stats,IDsdetails,by="UniProt_Name")
write.csv(export_stats,file= "results_noapc_with_stats.csv")

```

